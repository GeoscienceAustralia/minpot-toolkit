# Copyright (C) 2021-2023 Geoscience Australia
# 
# The minpot-toolkit is released under the Apache License, Version 2.0 
# (the "License");you may not use this software except in compliance with 
# the License. You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# The project uses third party components which may have different licenses. 
# Please refer to individual components for more details.
"""
Statistics module
-----------------
This module is used to investigate the statistical significance of any 
correlation present between mineral deposit locations and mappable proxies
derived from geophysical models.
    
"""

import numpy as np
import matplotlib.pyplot as plt
import toolkit.functions as fn
import toolkit.plotting as pt

from scipy.special import gammainc

class StatsManager():
    def __init__(self, commandList, statnodes):
        """
        A class to facilitate any statistical calculations which need to be 
        performed.
        
        
        Parameters
        ----------
        commandList: list
            A list of commands read from XML config file.
            
        statnodes: xml.ElementTree node
            A node, which contains within it nodes representing each statistial
            computation that must be performed.
            
        
        Calls
        -----
        functions.changetype
        
        
        """
        
        self.statnodes = statnodes

        for row in commandList:
            if hasattr(self, row[0]):
                tp = type(getattr(self, row[0]))
                val = fn.changetype(row[1], tp)
                setattr(self, row[0], val)
            #end if
        #end for
    #end func
    
    def Process(self, feature_dict, points_dict, RPManager):
        """
        Process to perform statistical computations.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feature objects which were generated by the feature
            engineering module.
            
        points_dict: dictionary
            Dictionary containing deposit locations which have been read in and
            filtered by the data input module.
            
        RPManager: IO.DataManager.RandomPointsManager object
            RandomPointsManager object which is given to the run_analysis 
            function to provide a set of randomly generated locations.
            
        
        Calls
        -----
        Kolmogorov_Smirnov_p_test
        
        Poisson_p_test
        
        Binomial_p_test
        
        
        """
        point_data = points_dict['point_data_filt']
        
        self.stat_obj_dict = {}
        for node in self.statnodes:
            key = node.attrib["name"]
            test_type = node.attrib["test"]
            if test_type == "Kolmogorov-Smirnov p test":
                stat = Kolmogorov_Smirnov_p_test(feature_dict, point_data, 
                                                 RPManager, node)
                self.stat_obj_dict[key] = stat
            elif test_type == "Poisson p test":
                stat = Poisson_p_test(feature_dict, point_data, RPManager, 
                                      node)
                self.stat_obj_dict[key] = stat
            #end if
            elif test_type == "Binomial p test":
                stat = Binomial_p_test(feature_dict, point_data, RPManager, 
                                       node)
                self.stat_obj_dict[key] = stat
            #end if
        #end for
#end class
    
class Kolmogorov_Smirnov_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform the Kolmogorov-Smirnov p test on a dataset.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        """
        self.name = node.attrib["name"]                
        self.feature_key = node.attrib["feature"]
        self.correlation = node.attrib["correlation"]
        self.binsize = fn.changetype(node.attrib["binsize"], float)
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        feature = feature_dict[self.feature_key]
        self.cdf = False
        self.pdf = False
        depths_type = node.attrib["depths_type"]
        depths = fn.changetype(node.attrib["depths"], "array", dtype=float)
        if depths_type == 'range':
            self.depths = list(np.arange(depths[0], depths[1], depths[2]))
        else:
            self.depths = depths
        #end if
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"], 
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.distance_array = make_distance_array(feature, point_data, 
                                                  self.n_repeats, 
                                                  RPManager=RPManager)
        self.Kolmogorov_Smirnov_p_test()
        self.print_results()
    #end func
    
    def compute_cdf(self):
        """
        Computes the cumulative distribution function for input dataset.
        
        
        Calls
        -----
        compute_cdf
        
        initialise_cdf_array
        
        
        """
        print('Computing CDF')
        if not hasattr(self, 'cdf_array'):
            self.cdf_array, self.n_deposits = \
                initialise_cdf_array(self.distance_array, self.binsize)
        #end if
        self.cdf_array = compute_cdf(self.distance_array, self.cdf_array)
        self.cdf = True
        print('Completed computing CDF')
    #end func
    
    def compute_pdf(self):
        """
        Computes the probability density function for input dataset.
        
        
        Calls
        -----
        compute_pdf
        
        initialise_cdf_array
        
        
        """
        print('Computing PDF')
        if not hasattr(self, 'cdf_array'):
            self.cdf_array, self.n_deposits = \
                initialise_cdf_array(self.distance_array, self.binsize)
        #end if
        self.cdf_array = compute_pdf(self.distance_array, self.cdf_array)
        self.pdf = True
        print('Completed computing PDF')
    #end func
    
    def compute_normed_cdf(self):
        """
        Computes the normalised cumulative distribution function from an
        already existing CDF.
        
        
        Calls
        -----
        compute_normed_cdf
        
        
        """
        if not self.cdf:
            self.compute_cdf()
        #end if
        print('Computing normed cdf')
        self.cdf_normed, self.cdf_random_normed, self.cdf_random_std, \
            self.dvalues, self.dmax = \
            compute_normed_cdf(self.cdf_array, self.n_deposits, 
                               self.correlation)
        print('Completed computing normed cdf')
    #end func
    
    def compute_normed_pdf(self):
        """
        Computes the normalised probability density function from an already 
        existing PDF.
        
        
        Calls
        -----
        compute_normed_pdf
        
        
        """
        if not self.pdf:
            self.compute_pdf()
        #end if
        print('Computing normed pdf')
        self.pdf_normed, self.pdf_random_normed, self.pdf_random_std = \
            compute_normed_pdf(self.cdf_array, self.n_deposits)
        print('Completed computing normed pdf')
    #end func
    
    def Kolmogorov_Smirnov_p_test(self):
        """
        Performs the Kolmogorov-Smirnov "p" test to determine the statistical
        significance of the results.
        
        
        """
        print('Computing Kolmogorov-Smirnov values')
        if not hasattr(self, 'dmax'):
            self.compute_normed_cdf()
        #end if
        self.kolmogorov_smirnov = \
            np.exp(-2.*(self.n_deposits**2)*(self.dmax**2)/(2*self.n_deposits))
        print('Completed computing Kolmogorov-Smirnov values')
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Path in which to save the figure.
        
        
        Calls
        -----
        plotting.plot_cdf_at_depth_slice
        
        plotting.plot_heat_map
        
        plotting.plot_kolmogorov_smirnov_values
        
        
        """
        pt.plot_cdf_at_depth_slice(self.depths, wd_images, obj=self)
        #pt.plot_pdf_at_depth_slice(self.depths, wd_images, obj=self)
        if len(self.depths) > 1:
            pt.plot_heat_map(wd_images, obj=self)
            pt.plot_kolmogorov_smirnov_values(wd_images, obj=self)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Number of deposits =', self.n_deposits)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('d values =', self.dmax)
        print('p values =', self.kolmogorov_smirnov)
    #end func
#end class
    
class Poisson_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform a p test on a dataset assuming it follows the 
        Poisson distribution, and to perform the chi squared test to determine
        if the Poisson distribution is followed.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        Calls
        -----
        functions.changetype
        
        IO.DataManager.RandomPointsManager.seed_random_points
        
        
        Called by
        ---------
        StatsManager.Process
        
        
        """                
        self.distribution = 'Poisson'
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        self.name = node.attrib["name"]
        self.dtf_dict = {}
        self.conditions = list()
        self.distance_arrays = list()
        self.n_points = len(point_data)
        depths_type = node.attrib["depths_type"]
        depths = fn.changetype(node.attrib["depths"], "array", dtype=float)
        if depths_type == 'range':
            self.depths = np.arange(depths[0], depths[1], depths[2])
        else:
            self.depths = depths
        #end if
        criteria = node.findall("criterion")
        points_random = \
            RPManager.seed_random_points(n_repeats=self.n_repeats)
        for criterion in criteria:
            feature_key = node.attrib["feature_key"]
            feature = feature_dict[feature_key]
            
            distance_array = make_distance_array(feature, point_data, 
                                                 self.n_repeats, 
                                                 points_random=points_random)
            self.distance_arrays.append(distance_array)
            _, rng, thr = fn.changetype(criterion.attrib["description"], list, 
                                        dtype=str)
            self.conditions.append([rng, float(thr)])
        #end for
        if len(criteria) == 1:
            self.feature_key = feature_key
        #end if
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"], 
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.Poisson_p_test()
        self.chi_squared_test()
        self.print_results()
    #end func
    
    def compute_truth_arrays(self):
        """
        Used to determine if data points fulfil all conditions required.
        
        
        Calls
        -----
        compute_truth_arrays
        
        
        """
        self.real_truth_array, self.random_truth_array = \
            compute_truth_arrays(self.distance_arrays, self.conditions)
    #end func
    
    def compute_parameters_for_Poisson_test(self):
        """
        Computes parameters required for the Poisson p test.
        
        
        Calls
        -----
        compute_parameters_for_p_test
        
        
        """
        if not hasattr(self, 'real_truth_array'):
            self.compute_truth_arrays()
        #end if
        self.xvals, self.mvals, self.svals, self.rvals = \
            compute_parameters_for_p_test(self.real_truth_array,
                                          self.random_truth_array, 
                                          self.n_points)
    #end func
    
    def chi_squared_test(self):
        """
        Performs the chi squared test to determine if the random point dataset
        follows the Poisson distribution.
        
        
        Calls
        -----
        chi_squared_test
        
        
        """
        if not hasattr(self, 'pvals'):
            self.Poisson_p_test()
        #end if
        self.chi_t_vals, self.chi_p_vals, self.chi_k_vals = \
            chi_squared_test(self.rvals, self.n_points, self.distribution)
        #end func
    #end func
    
    def Poisson_p_test(self):
        """
        Performs a p test to determine if a result is statistically 
        significant, if the data is assumed to follow the Poisson distribution.
        
        
        Calls
        -----
        Poisson_test
        
        
        """
        if not hasattr(self, 'xvals'):
            self.compute_parameters_for_Poisson_test()
        #end if
        self.pvals = Poisson_test(self.xvals, self.mvals, self.n_points)
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Directory in which to save figures.
        
        
        Calls
        -----
        plotting.plot_distribution_at_depth_slice
        
        plotting.plot_Poisson_p_values
        
        
        """
        pt.plot_distribution_at_depth_slice(self, self.depths, wd_images)
        if len(self.depths) > 1:
            pt.plot_Poisson_p_values(self, wd_images)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Test distribution type =', self.distribution)
        print('Number of deposits =', self.n_points)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('Criteria:')
        criteria = self.node.findall("criterion")
        for criterion in criteria:
            name = criterion.attrib["name"]
            _, target_range, target_value = \
                fn.changetype(criterion.attrib["description"], list, dtype=str)
            feature = criterion.attrib["feature"]
            print('%s:'%name, 'distance', target_range, target_value, 'from',
                  feature)
        #end for
        print(self.distribution, 'distribution probability test results:')
        print('Proportion of deposits satisfying criteria, x =', self.xvals)
        print('Proportion of random points satisfying criteria, m =', 
              self.mvals)
        print('Probability of obtaining x with mean m, p =', self.pvals)
        print('Chi squared test results:')
        print('t values =', self.chi_t_vals)
        print('p values =', self.chi_p_vals)
        print('k values =', self.chi_k_vals)
    #end func
#end class
    
class Binomial_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform a p test on a dataset assuming it follows the 
        Binomial distribution, and to perform the chi squared test to determine
        if the Binomial distribution is followed.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        Calls
        -----
        functions.changetype
        
        IO.DataManager.RandomPointsManager.seed_random_points
        
        
        """       
        self.distribution = 'Binomial'         
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        self.name = node.attrib["name"]
        self.dtf_dict = {}
        self.conditions = list()
        self.features = list()
        self.distance_arrays = list()
        self.n_points = len(point_data)
        self.node = node
        depths_type = self.node.attrib["depths_type"]
        depths = fn.changetype(self.node.attrib["depths"], "array", 
                               dtype=float)
        if depths_type == 'range':
            self.depths = list(np.arange(depths[0], depths[1], depths[2]))
        else:
            self.depths = depths
        #end if
        criteria = self.node.findall("criterion")
        points_random = \
            RPManager.seed_random_points(n_repeats=self.n_repeats)
        for criterion in criteria:
            feature_key = criterion.attrib["feature"]
            feature = feature_dict[feature_key]
            self.features.append(feature)
            
            distance_array = make_distance_array(feature, point_data, 
                                                 self.n_repeats, 
                                                 points_random=points_random)
            self.distance_arrays.append(distance_array)
            _, rng, thr = fn.changetype(criterion.attrib["description"], list,
                                        dtype=str)
            self.conditions.append([rng, float(thr)])
        #end for
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"],
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.Binomial_p_test()
        self.chi_squared_test()
        self.print_results()
    #end func
    
    def compute_truth_arrays(self):
        """
        Used to determine if data points fulfil all conditions required.
        
        
        Calls
        -----
        compute_truth_arrays
        
        
        """
        self.real_truth_array, self.random_truth_array = \
            compute_truth_arrays(self.distance_arrays, self.conditions)
    #end func
    
    def compute_parameters_for_binomial_test(self):
        """
        Computes parameters required for the Poisson p test.
        
        
        Calls
        -----
        compute_parameters_for_p_test
        
        
        """
        if not hasattr(self, 'real_truth_array'):
            self.compute_truth_arrays()
        #end if
        self.xvals, self.mvals, self.svals, self.rvals = \
            compute_parameters_for_p_test(self.real_truth_array,
                                          self.random_truth_array, 
                                          self.n_points)
    #end func
    
    def chi_squared_test(self):
        """
        Performs the chi squared test to determine if the random point dataset
        follows the Poisson distribution.
        
        
        Calls
        -----
        chi_squared_test
        
        
        """
        if not hasattr(self, 'pvals'):
            self.Binomial_p_test()
        #end if
        self.chi_t_vals, self.chi_p_vals, self.chi_k_vals = \
            chi_squared_test(self.rvals, self.n_points, self.distribution)
        #end func
    #end func
    
    def Binomial_p_test(self):
        """
        Performs a p test to determine if a result is statistically 
        significant, if the data is assumed to follow the Binomial 
        distribution.
        
        
        Calls
        -----
        Binomial_test
        
        
        """
        if not hasattr(self, 'xvals'):
            self.compute_parameters_for_binomial_test()
        #end if
        self.pvals = Binomial_test(self.xvals, self.mvals, self.n_points)
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Directory in which to save figures.
        
        
        Calls
        -----
        plotting.plot_distribution_at_depth_slice
        
        plotting.plot_Binomial_p_values
        
        
        """
        pt.plot_distribution_at_depth_slice(self, self.depths, wd_images)
        if len(self.depths) > 1:
            pt.plot_Binomial_p_values(self, wd_images)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Test distribution type =', self.distribution)
        print('Number of deposits =', self.n_points)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('Criteria:')
        criteria = self.node.findall("criterion")
        for criterion in criteria:
            name = criterion.attrib["name"]
            _, target_range, target_value = \
                fn.changetype(criterion.attrib["description"], list, dtype=str)
            feature = criterion.attrib["feature"]
            print('%s:'%name, 'distance', target_range, target_value, 'from',
                  feature)
        #end for
        print(self.distribution, 'distribution probability test results:')
        print('Proportion of deposits satisfying criteria, x =', self.xvals)
        print('Proportion of random points satisfying criteria, m =', 
              self.mvals)
        print('Probability of obtaining x with mean m, p =', self.pvals)
        print('Chi squared test results:')
        print('t values =', self.chi_t_vals)
        print('p values =', self.chi_p_vals)
        print('k values =', self.chi_k_vals)
    #end func
#end class
    
def chi_squared_test(rvals, n_points, distribution):
    """
    Performs the chi squared test to determine whether or not a data set
    follows a given distribution.
    
    
    Parameters
    ----------
    rvals: numpy array
        2D array with dimensions (n_depths, n_repeats) representing the 
        proportions of points which fulfil the criteria of the statistical 
        test.
        
    n_points: integer
        The number of deposit locations used.
        
    distribution: string
        Flag representing which distribution to test the data against. 
        Supported values are 'Poisson' and 'Binomial'.
        
        
    Returns
    -------
    tvals: numpy array
        1D numpy array representing the test statistic values calculated for
        each depth.
        
    pvals: numpy array
        1D numpy array representing the p values at each depth.
        
    kvals: numpy array
        1D numpy array representing degrees of freedom at each depth.
        
        
    Calls
    -----
    functions.Poisson
    
    functions.binomial
    
    
   """
    tvals = list()
    pvals = list()
    kvals = list()
    for i in range(len(rvals)):
        r = rvals[i]*n_points
        freqs, binedges = np.histogram(r, bins=n_points+1, 
                                       range=(0, n_points+1))
        x = binedges[:-1]
        m = np.mean(r)
        if distribution == 'Poisson':
            y = fn.Poisson(x, m)*len(r)
        elif distribution == 'Binomial':
            y = fn.binomial(x, m, n_points)*len(r)
        #end if
        #Maybe make smallest allowable expectation value an input?
        #maxind = np.max(np.where(y >= np.max([5, 0.01*len(r)]))[0])
        bins = np.where(y >= 5)[0]
        minind = np.min(bins)
        maxind = np.max(bins)
        #DoF = Number of bins minus 1, minus 1 because of assumed mean
        if len(bins) > 2:
            k = len(bins) - 2
            freqs = freqs[minind:maxind]
            y = y[minind:maxind]
            O = np.hstack([freqs, np.array([len(r) - np.sum(freqs)])])
            E = np.hstack([y, np.array([len(r) - np.sum(y)])])
            chi2 = np.sum((O-E)**2/E)
            p = 1 - gammainc(k/2, chi2/2)
            tvals.append(chi2)
            pvals.append(p)
            kvals.append(k)
        else:
            tvals.append(np.nan)
            pvals.append(np.nan)
            kvals.append(np.nan)
        #end if
    #end for
    return np.array(tvals), np.array(pvals), np.array(kvals)
#end func
    
def compute_truth_arrays(distance_arrays, conditions, 
                         grouping_type='intersection'):
    """
    Determines whether or not a set of points fulfils the given conditions.
    
    
    Parameters
    ----------
    distance_arrays: list
        List of structured numpy arrays containing distances from deposit 
        locations and random locations from features under investigation.
        
    conditions: list
        A list of lists. Each sub list is to contain two elements:
            1. "range" to use, e.g. 'less than', 'greater than'
            2. Threshold value to compare to.
            
    grouping_type: string
        Either 'intersection' or 'union'. If 'intersection', all criteria must
        be fulfilled. If 'union', any criterion must be fulfilled.
        
        
    Returns
    -------
    truth1: numpy array
        Array of truth values representing whether or not deposit locations 
        fulfil the criteria.
        
    truth2: numpy array
        Array of truth values representing whether or not random locations 
        fulfil the criteria.
    
    
    """
    list1 = list()
    list2 = list()
    for i in range(len(distance_arrays)):
        condition = conditions[i]
        thr = condition[1]
        rng = condition[0]
        distance_array = distance_arrays[i]
        distances = distance_array['distance']
        distances_random = distance_array['distance_random']
        if rng == 'less than':
            list1.append(distances < thr)
            list2.append(distances_random < thr)
        elif rng == 'greater than':
            list1.append(distances > thr)
            list2.append(distances_random > thr)
        #end if
    #end for
    if grouping_type == 'union':
        truth1 = np.any(list1, axis=0)
        truth2 = np.any(list2, axis=0)
    elif grouping_type == 'intersection':
        truth1 = np.all(list1, axis=0)
        truth2 = np.all(list2, axis=0)
    #end if
    return truth1, truth2
#end func

def compute_parameters_for_p_test(real, random, n_points):
    """
    Computes parameters for the Poisson p test.
    
    
    Parameters
    ----------
    real: numpy array
        2D rray of truth values representing whether or not a deposit location
        satisfies all criteria, for each depth.
        
    random: numpy array
        3D Array of truth values representing whether or not a random location
        satisfies all criteria, for each repeat, for each depth.
        
    n_points: integer
        The number of deposit locationsused.
        
        
    Returns
    -------
    xvals: numpy array
        1D array, containing the proportion of points at each depth which 
        satisfied all criteria.
        
    rvals: numpy array
        2D array, containing the proportion of points for each repeat and for
        each depth which satisfied all criteria.
        
    mvals: numpy array
        1D array containing the mean value of rvals at each depth.
        
    svals: numpy array
        1D array containing the standard deviation of rvals at each depth.
    
    
    """
    xvals = np.sum(real, axis=1)/n_points
    rvals = np.sum(random, axis=2)/n_points
    mvals = np.mean(rvals, axis=1)
    svals = np.std(rvals, axis=1)
    return xvals, mvals, svals, rvals
#end func
    
def compute_cdf(distance_array, cdf_array):
    """
    Computes the cumulative distribution function for the distances from 
    deposit locations and random locations to a feature.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing the distances from deposits and random 
        locations to the feature.
        
    cdf_array: numpy array
        Structured array to enter the CDF into.
        
        
    Returns
    -------
    cdf_array: numpy array
        Structured array to with CDF entered into it.
        
    
    """
    distances = distance_array['distance']
    distance_random = distance_array['distance_random']
    
    for i in range(distances.shape[0]):
        
        hist_kwargs = dict(cumulative=True, bins=cdf_array['bins'][i], 
                           histtype='step', density=False)
        rhist_kwargs = dict(cumulative=True, bins=cdf_array['bins'][i], 
                            histtype='step', density=False)
  
        if not np.all(distances[i] == 0):
            cdf_array['cdf'][i], _, _= \
                plt.hist(distances[i], **hist_kwargs)
        #end if

        for j in range(distance_random.shape[1]):
            cdf_array['cdf_random'][i, j], _, _ = \
                plt.hist(distance_random[i, j], **rhist_kwargs)
        #end if
    #end for
    plt.close()
    return cdf_array
#end func

def compute_normed_cdf(cdf_array, n_deposits, correlation):
    """
    Computes a normed cumulative distribution function from an already existing
    CDF, and computes the maximum distance (d value) between the CDFs for real 
    deposit locations and random locations.
    
    
    Parameters
    ----------
    cdf_array: numpy array
        Structured array containing the CDF.
        
    n_deposits: integer
        Number of deposits used.
        
    correlation: string
        Either 'Positive', 'Negative', or 'Neutral' to describe whether we want
        the d value for a positive or negative correlation, or any.
        
    
    Returns
    -------
    cdf_normed: numpy array
        2D array containing the normed CDF for real deposits at each depth.
    
    cdf_random_normed: numpy array
        2D array containing the mean of the normed CDF for random locations for 
        each repeat at each depth.
    
    cdf_random_std: numpy array
        2D array containing the standard deviation for cdf_random_normed at 
        each depth.
    
    dvalues: numpy array
        The difference between cdf_normed and cdf_random_normed at each depth.
    
    dmax: numpy array
        The maximum value of dvalues at each depth.
    
    
    """

    cdf_normed = cdf_array['cdf']/n_deposits
    cdf_random_normed = np.mean(cdf_array['cdf_random'], axis=1)/n_deposits
    cdf_random_std = np.std(cdf_array['cdf_random'], axis=1)/n_deposits        

    if correlation == 'Positive':
        dvalues = cdf_normed - cdf_random_normed
    elif correlation == 'Negative':
        dvalues = cdf_random_normed - cdf_normed
    elif correlation == 'Neutral':
        dvalues = np.abs(cdf_normed - cdf_random_normed)
    #end if

    dmax = np.nanmax(dvalues, axis=1)
    return cdf_normed, cdf_random_normed, cdf_random_std, dvalues, dmax
#end func 
    
def compute_normed_pdf(cdf_array, n_deposits):
    """
    Computes a normed probability density function from an already existing 
    PDF, for real deposit locations and random locations.
    
    
    Parameters
    ----------
    cdf_array: numpy array
        Structured array containing the PDF.
        
    n_deposits: integer
        Number of deposits used.
        
    
    Returns
    -------
    pdf_normed: numpy array
        2D array containing the normed PDF for real deposits at each depth.
    
    pdf_random_normed: numpy array
        2D array containing the mean of the normed PDF for random locations for 
        each repeat at each depth.
    
    pdf_random_std: numpy array
        2D array containing the standard deviation for pdf_random_normed at 
        each depth.
    
    
    """

    pdf_normed = cdf_array['pdf']/n_deposits
    pdf_random_normed = np.mean(cdf_array['pdf_random'], axis=1)/n_deposits
    pdf_random_std = np.std(cdf_array['pdf_random'], axis=1)/n_deposits        

    return pdf_normed, pdf_random_normed, pdf_random_std
#end func 
    
def compute_pdf(distance_array, cdf_array):
    """
    Computes the probability density function for the distances from deposit 
    locations and random locations to a feature.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing the distances from deposits and random 
        locations to the feature.
        
    cdf_array: numpy array
        Structured array to enter the PDF into.
        
        
    Returns
    -------
    cdf_array: numpy array
        Structured array to with CDF entered into it.
        
    
    """
    distances = distance_array['distance']
    distance_random = distance_array['distance_random']
    
    for i in range(distances.shape[0]):
        
        hist_kwargs = dict(cumulative=False, bins=cdf_array['bins'][i], 
                           histtype='step', density=False)
        rhist_kwargs = dict(cumulative=False, bins=cdf_array['bins'][i], 
                            histtype='step', density=False)
  
        if not np.all(distances[i] == 0):
            cdf_array['pdf'][i], _, _= \
                plt.hist(distances[i], **hist_kwargs)
        #end if

        for j in range(distance_random.shape[1]):
            cdf_array['pdf_random'][i, j], _, _ = \
                plt.hist(distance_random[i, j], **rhist_kwargs)
        #end if
    #end for
    plt.close()
    return cdf_array
#end func

def initialise_bins(binsize, distance_array):
    """
    Takes a distance array and computes the bins needed for a histogram, to 
    compute the PDF and CDF for the distances.
    
    
    Parameters
    ----------
    binsize: float
        Width of bin in histogram.
        
    distance_array: numpy array
        Structured array containing distance to feature information.
        
        
    Returns
    -------
    bins: numpy array
        The values at the edges of each bin. Will have length nbins + 1.
        
    binc: numpy array
        The value at the centre of each bin. Will have length nbins.
        
    
    """
    if binsize is None:
        binsize = 2e3
    #end if
    min_random = distance_array['distance_random'].min()
    min_real =distance_array['distance'].min()
    max_random = distance_array['distance_random'].max()
    max_real = distance_array['distance'].max()
    min_val = min(min_random, min_real)
    max_val = max(max_random, max_real)
    bins = np.arange((np.floor(min_val/binsize)-1.0), 
                     (np.ceil(max_val/binsize)+1.0),
                     1.0)*binsize
    binc = np.mean([bins[:-1], bins[1:]],axis=0) 
    return bins, binc    
#end func
    
def initialise_cdf_array(distance_array, binsize):
    """
    Creates a structured array to store computed CDFs and PDFs.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing distance to feature information.
        
    binsize: float
        Width of bin in histogram.
        
        
    Returns
    -------
    array: numpy array
        Structured array designed to contain CDF and PDF information.
        
    n_deposits: integer
        Number of deposits used for analysis.
        
    
    Calls
    -----
    initialise_bins
    
    
    """
    
    bins, binc = initialise_bins(binsize, distance_array)
    # initialise an array to contain cdf
    n_bins = binc.shape[0]
    n_repeats = distance_array['distance_random'].shape[1]
    array = np.zeros(len(distance_array['distance']),
                     dtype=[('depth', np.float64), 
                            ('binc', np.float64, binc.shape),
                            ('bins', np.float64, bins.shape),
                            ('cdf_random', np.float64, (n_repeats, n_bins)),
                            ('cdf', np.float64, binc.shape),
                            ('pdf_random', np.float64, (n_repeats, n_bins)),
                            ('pdf', np.float64, binc.shape)])
    array['depth'] = distance_array['depth']
    for i in range(distance_array['distance'].shape[0]):
        array['bins'][i] = bins
        array['binc'][i] = binc
    #end for
    n_deposits = distance_array['distance'].shape[1]
    return array, n_deposits
#end func
    
def Poisson_test(x, m, n_points):
    """
    Performs a test to determine the probability of a given result occurring
    if the Poisson distribution is followed.
    
    
    Parameters
    ----------
    x: numpy array
        1D array containing the observed number of points which fulfilled a set
        of criteria at each depth.
        
    m: numpy array
        1D array containing the observed number of random locations which 
        fulfilled the same set of criteria as x at each depth.
        
    n_points: integer
        The number of points used.
        
    
    Returns
    -------
    pvals: numpy array
        1D array containing the probability that 'x' could occur with mean 'm' 
        for each depth.
        
        
    Calls
    -----
    functions.Poisson
    
    
    """
    pvals = list()
    for i in range(len(x)):
        p = fn.Poisson(x[i]*n_points, m[i]*n_points)
        pvals.append(p)
    #end func
    return np.array(pvals)
#end func
    
def Binomial_test(x, m, n_points):
    """
    Performs a test to determine the probability of a given result occurring
    if the Binomial distribution is followed.
    
    
    Parameters
    ----------
    x: numpy array
        1D array containing the observed number of points which fulfilled a set
        of criteria at each depth.
        
    m: numpy array
        1D array containing the observed number of random locations which 
        fulfilled the same set of criteria as x at each depth.
        
    n_points: integer
        The number of points used.
        
    
    Returns
    -------
    pvals: numpy array
        1D array containing the probability that 'x' could occur with mean 'm' 
        for each depth.
        
        
    Calls
    -----
    functions.binomial
    
    
    """
    pvals = list()
    for i in range(len(x)):
        p = fn.binomial(x[i]*n_points, m[i]*n_points, n_points)
        pvals.append(p)
    #end func
    return np.array(pvals)
#end func
    
def make_distance_array(feature, point_data, n_repeats, points_random=None, 
                        RPManager=None):
    """
    Make and populate an array to contain distances to contour.
    
    
    Parameters
    ----------
    point_data_xy : array
        Array of projected coordinates of deposit locations for which distances 
        are to be computed.
    
    gcz : array
        Array of depth values for which geophysical model was created.
    
    n_repeats : int
        Number of repeats of the analysis to perform for random points.
        
    
    Returns
    -------
    distance_array : array
        Structured array to contain distance-to-contour data.
    
        
    """
    
    # initialise structured array to contain distance-to-contour data  
    gcz = feature.gcz
    n_points = len(point_data)
    distance_array = np.array(np.zeros(len(gcz)),
                              dtype=[('depth', np.float64),
                                     ('lon',np.float64, n_points),
                                     ('lat',np.float64, n_points),
                                     ('distance_random', np.float64, \
                                      (n_repeats, n_points)),
                                     ('distance', np.float64, n_points)])
    distance_array['depth'] = gcz
    distance_array['lon'] = point_data[:,0]
    distance_array['lat'] = point_data[:,1]
    if points_random is None:
        points_random = RPManager.seed_random_points(n_repeats=n_repeats)
    #end if
    if len(gcz) == 1:
        distance_array['distance'][0] = \
            feature.fun((point_data[:,0], point_data[:,1]))
        distance_array['distance_random'][0] = \
            feature.fun((points_random[:,:,0], points_random[:,:,1]))
    else:
        for i in range(len(gcz)):
            distance_array['distance'][i] = \
                feature.fun((point_data[:,0], point_data[:,1], 
                             gcz[i]*np.ones_like(point_data[:,0])))
            distance_array['distance_random'][i] = \
                feature.fun((points_random[:,:,0], points_random[:,:,1], 
                             gcz[i]*np.ones_like(points_random[:,:,0])))
        #end for
    #end if
    return distance_array
#end func
