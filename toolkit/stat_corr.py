"""
Statistics module
-----------------
This module is used to investigate the statistical significance of any 
correlation present between mineral deposit locations and mappable proxies
derived from geophysical models.


Contacts
--------
Lachlan Adams
    - Lachlan.Adams@ga.gov.au or Lachlan.Adams.1996@outlook.com
    
    
"""

import numpy as np
import matplotlib.pyplot as plt
import toolkit.functions as fn
import toolkit.plotting as pt

from scipy.special import gammainc

class StatsManager():
    def __init__(self, commandList, statnodes):
        """
        A class to facilitate any statistical calculations which need to be 
        performed.
        
        
        Parameters
        ----------
        commandList: list
            A list of commands read from XML config file.
            
        statnodes: xml.ElementTree node
            A node, which contains within it nodes representing each statistial
            computation that must be performed.
            
        
        Calls
        -----
        functions.changetype
        
        
        """
        
        self.statnodes = statnodes

        for row in commandList:
            if hasattr(self, row[0]):
                tp = type(getattr(self, row[0]))
                val = fn.changetype(row[1], tp)
                setattr(self, row[0], val)
            #end if
        #end for
    #end func
    
    def Process(self, feature_dict, points_dict, RPManager):
        """
        Process to perform statistical computations.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feature objects which were generated by the feature
            engineering module.
            
        points_dict: dictionary
            Dictionary containing deposit locations which have been read in and
            filtered by the data input module.
            
        RPManager: IO.DataManager.RandomPointsManager object
            RandomPointsManager object which is given to the run_analysis 
            function to provide a set of randomly generated locations.
            
        
        Calls
        -----
        Kolmogorov_Smirnov_p_test
        
        Poisson_p_test
        
        Binomial_p_test
        
        
        """
        point_data = points_dict['point_data_filt']
        
        self.stat_obj_dict = {}
        for node in self.statnodes:
            key = node.attrib["name"]
            test_type = node.attrib["test"]
            if test_type == "Kolmogorov-Smirnov p test":
                stat = Kolmogorov_Smirnov_p_test(feature_dict, point_data, 
                                                 RPManager, node)
                self.stat_obj_dict[key] = stat
            elif test_type == "Poisson p test":
                stat = Poisson_p_test(feature_dict, point_data, RPManager, 
                                      node)
                self.stat_obj_dict[key] = stat
            #end if
            elif test_type == "Binomial p test":
                stat = Binomial_p_test(feature_dict, point_data, RPManager, 
                                       node)
                self.stat_obj_dict[key] = stat
            #end if
        #end for
#end class
    
class Kolmogorov_Smirnov_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform the Kolmogorov-Smirnov p test on a dataset.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        """
        self.name = node.attrib["name"]                
        self.feature_key = node.attrib["feature"]
        self.correlation = node.attrib["correlation"]
        self.binsize = fn.changetype(node.attrib["binsize"], float)
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        feature = feature_dict[self.feature_key]
        self.cdf = False
        self.pdf = False
        depths_type = node.attrib["depths_type"]
        depths = fn.changetype(node.attrib["depths"], "array", dtype=float)
        if depths_type == 'range':
            self.depths = list(np.arange(depths[0], depths[1], depths[2]))
        else:
            self.depths = depths
        #end if
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"], 
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.distance_array = make_distance_array(feature, point_data, 
                                                  self.n_repeats, 
                                                  RPManager=RPManager)
        self.Kolmogorov_Smirnov_p_test()
        self.print_results()
    #end func
    
    def compute_cdf(self):
        """
        Computes the cumulative distribution function for input dataset.
        
        
        Calls
        -----
        compute_cdf
        
        initialise_cdf_array
        
        
        """
        print('Computing CDF')
        if not hasattr(self, 'cdf_array'):
            self.cdf_array, self.n_deposits = \
                initialise_cdf_array(self.distance_array, self.binsize)
        #end if
        self.cdf_array = compute_cdf(self.distance_array, self.cdf_array)
        self.cdf = True
        print('Completed computing CDF')
    #end func
    
    def compute_pdf(self):
        """
        Computes the probability density function for input dataset.
        
        
        Calls
        -----
        compute_pdf
        
        initialise_cdf_array
        
        
        """
        print('Computing PDF')
        if not hasattr(self, 'cdf_array'):
            self.cdf_array, self.n_deposits = \
                initialise_cdf_array(self.distance_array, self.binsize)
        #end if
        self.cdf_array = compute_pdf(self.distance_array, self.cdf_array)
        self.pdf = True
        print('Completed computing PDF')
    #end func
    
    def compute_normed_cdf(self):
        """
        Computes the normalised cumulative distribution function from an
        already existing CDF.
        
        
        Calls
        -----
        compute_normed_cdf
        
        
        """
        if not self.cdf:
            self.compute_cdf()
        #end if
        print('Computing normed cdf')
        self.cdf_normed, self.cdf_random_normed, self.cdf_random_std, \
            self.dvalues, self.dmax = \
            compute_normed_cdf(self.cdf_array, self.n_deposits, 
                               self.correlation)
        print('Completed computing normed cdf')
    #end func
    
    def compute_normed_pdf(self):
        """
        Computes the normalised probability density function from an already 
        existing PDF.
        
        
        Calls
        -----
        compute_normed_pdf
        
        
        """
        if not self.pdf:
            self.compute_pdf()
        #end if
        print('Computing normed pdf')
        self.pdf_normed, self.pdf_random_normed, self.pdf_random_std = \
            compute_normed_pdf(self.cdf_array, self.n_deposits)
        print('Completed computing normed pdf')
    #end func
    
    def Kolmogorov_Smirnov_p_test(self):
        """
        Performs the Kolmogorov-Smirnov "p" test to determine the statistical
        significance of the results.
        
        
        """
        print('Computing Kolmogorov-Smirnov values')
        if not hasattr(self, 'dmax'):
            self.compute_normed_cdf()
        #end if
        self.kolmogorov_smirnov = \
            np.exp(-2.*(self.n_deposits**2)*(self.dmax**2)/(2*self.n_deposits))
        print('Completed computing Kolmogorov-Smirnov values')
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Path in which to save the figure.
        
        
        Calls
        -----
        plotting.plot_cdf_at_depth_slice
        
        plotting.plot_heat_map
        
        plotting.plot_kolmogorov_smirnov_values
        
        
        """
        pt.plot_cdf_at_depth_slice(self.depths, wd_images, obj=self)
        #pt.plot_pdf_at_depth_slice(self.depths, wd_images, obj=self)
        if len(self.depths) > 1:
            pt.plot_heat_map(wd_images, obj=self)
            pt.plot_kolmogorov_smirnov_values(wd_images, obj=self)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Number of deposits =', self.n_deposits)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('d values =', self.dmax)
        print('p values =', self.kolmogorov_smirnov)
    #end func
#end class
    
class Poisson_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform a p test on a dataset assuming it follows the 
        Poisson distribution, and to perform the chi squared test to determine
        if the Poisson distribution is followed.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        Calls
        -----
        functions.changetype
        
        IO.DataManager.RandomPointsManager.seed_random_points
        
        
        Called by
        ---------
        StatsManager.Process
        
        
        """                
        self.distribution = 'Poisson'
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        self.name = node.attrib["name"]
        self.dtf_dict = {}
        self.conditions = list()
        self.distance_arrays = list()
        self.n_points = len(point_data)
        depths_type = node.attrib["depths_type"]
        depths = fn.changetype(node.attrib["depths"], "array", dtype=float)
        if depths_type == 'range':
            self.depths = np.arange(depths[0], depths[1], depths[2])
        else:
            self.depths = depths
        #end if
        criteria = node.findall("criterion")
        points_random = \
            RPManager.seed_random_points(n_repeats=self.n_repeats)
        for criterion in criteria:
            feature_key = node.attrib["feature_key"]
            feature = feature_dict[feature_key]
            
            distance_array = make_distance_array(feature, point_data, 
                                                 self.n_repeats, 
                                                 points_random=points_random)
            self.distance_arrays.append(distance_array)
            _, rng, thr = fn.changetype(criterion.attrib["description"], list, 
                                        dtype=str)
            self.conditions.append([rng, float(thr)])
        #end for
        if len(criteria) == 1:
            self.feature_key = feature_key
        #end if
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"], 
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.Poisson_p_test()
        self.chi_squared_test()
        self.print_results()
    #end func
    
    def compute_truth_arrays(self):
        """
        Used to determine if data points fulfil all conditions required.
        
        
        Calls
        -----
        compute_truth_arrays
        
        
        """
        self.real_truth_array, self.random_truth_array = \
            compute_truth_arrays(self.distance_arrays, self.conditions)
    #end func
    
    def compute_parameters_for_Poisson_test(self):
        """
        Computes parameters required for the Poisson p test.
        
        
        Calls
        -----
        compute_parameters_for_p_test
        
        
        """
        if not hasattr(self, 'real_truth_array'):
            self.compute_truth_arrays()
        #end if
        self.xvals, self.mvals, self.svals, self.rvals = \
            compute_parameters_for_p_test(self.real_truth_array,
                                          self.random_truth_array, 
                                          self.n_points)
    #end func
    
    def chi_squared_test(self):
        """
        Performs the chi squared test to determine if the random point dataset
        follows the Poisson distribution.
        
        
        Calls
        -----
        chi_squared_test
        
        
        """
        if not hasattr(self, 'pvals'):
            self.Poisson_p_test()
        #end if
        self.chi_t_vals, self.chi_p_vals, self.chi_k_vals = \
            chi_squared_test(self.rvals, self.n_points, self.distribution)
        #end func
    #end func
    
    def Poisson_p_test(self):
        """
        Performs a p test to determine if a result is statistically 
        significant, if the data is assumed to follow the Poisson distribution.
        
        
        Calls
        -----
        Poisson_test
        
        
        """
        if not hasattr(self, 'xvals'):
            self.compute_parameters_for_Poisson_test()
        #end if
        self.pvals = Poisson_test(self.xvals, self.mvals, self.n_points)
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Directory in which to save figures.
        
        
        Calls
        -----
        plotting.plot_distribution_at_depth_slice
        
        plotting.plot_Poisson_p_values
        
        
        """
        pt.plot_distribution_at_depth_slice(self, self.depths, wd_images)
        if len(self.depths) > 1:
            pt.plot_Poisson_p_values(self, wd_images)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Test distribution type =', self.distribution)
        print('Number of deposits =', self.n_points)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('Criteria:')
        criteria = self.node.findall("criterion")
        for criterion in criteria:
            name = criterion.attrib["name"]
            _, target_range, target_value = \
                fn.changetype(criterion.attrib["description"], list, dtype=str)
            feature = criterion.attrib["feature"]
            print('%s:'%name, 'distance', target_range, target_value, 'from',
                  feature)
        #end for
        print(self.distribution, 'distribution probability test results:')
        print('Proportion of deposits satisfying criteria, x =', self.xvals)
        print('Proportion of random points satisfying criteria, m =', 
              self.mvals)
        print('Probability of obtaining x with mean m, p =', self.pvals)
        print('Chi squared test results:')
        print('t values =', self.chi_t_vals)
        print('p values =', self.chi_p_vals)
        print('k values =', self.chi_k_vals)
    #end func
#end class
    
class Binomial_p_test():
    def __init__(self, feature_dict, point_data, RPManager, node):
        """
        A class used to perform a p test on a dataset assuming it follows the 
        Binomial distribution, and to perform the chi squared test to determine
        if the Binomial distribution is followed.
        
        
        Parameters
        ----------
        feature_dict: dictionary
            Dictionary of feat_eng.feature_object objects, containing each
            feature needed for the analysis.
            
        point_data_xy: numpy array
            Array of deposit locations.
            
        RPManager: IO.DataManager.RandomPointsManager object
            Object which facilitates the generation of random locations to 
            compare to actual deposit locations.
            
        node: xml.ElementTree node
            Node which contains commands and information about the test to be 
            performed.
        
        
        Calls
        -----
        functions.changetype
        
        IO.DataManager.RandomPointsManager.seed_random_points
        
        
        """       
        self.distribution = 'Binomial'         
        self.n_repeats = fn.changetype(node.attrib["n_repeats"], int)
        self.name = node.attrib["name"]
        self.dtf_dict = {}
        self.conditions = list()
        self.features = list()
        self.distance_arrays = list()
        self.n_points = len(point_data)
        self.node = node
        depths_type = self.node.attrib["depths_type"]
        depths = fn.changetype(self.node.attrib["depths"], "array", 
                               dtype=float)
        if depths_type == 'range':
            self.depths = list(np.arange(depths[0], depths[1], depths[2]))
        else:
            self.depths = depths
        #end if
        criteria = self.node.findall("criterion")
        points_random = \
            RPManager.seed_random_points(n_repeats=self.n_repeats)
        for criterion in criteria:
            feature_key = criterion.attrib["feature"]
            feature = feature_dict[feature_key]
            self.features.append(feature)
            
            distance_array = make_distance_array(feature, point_data, 
                                                 self.n_repeats, 
                                                 points_random=points_random)
            self.distance_arrays.append(distance_array)
            _, rng, thr = fn.changetype(criterion.attrib["description"], list,
                                        dtype=str)
            self.conditions.append([rng, float(thr)])
        #end for
        
        if "pros_map" in node.attrib:
            self.prospectivity_map = fn.changetype(node.attrib["pros_map"],
                                                   bool)
        else:
            self.prospectivity_map = False
        #end if
        
        self.Binomial_p_test()
        self.chi_squared_test()
        self.print_results()
    #end func
    
    def compute_truth_arrays(self):
        """
        Used to determine if data points fulfil all conditions required.
        
        
        Calls
        -----
        compute_truth_arrays
        
        
        """
        self.real_truth_array, self.random_truth_array = \
            compute_truth_arrays(self.distance_arrays, self.conditions)
    #end func
    
    def compute_parameters_for_binomial_test(self):
        """
        Computes parameters required for the Poisson p test.
        
        
        Calls
        -----
        compute_parameters_for_p_test
        
        
        """
        if not hasattr(self, 'real_truth_array'):
            self.compute_truth_arrays()
        #end if
        self.xvals, self.mvals, self.svals, self.rvals = \
            compute_parameters_for_p_test(self.real_truth_array,
                                          self.random_truth_array, 
                                          self.n_points)
    #end func
    
    def chi_squared_test(self):
        """
        Performs the chi squared test to determine if the random point dataset
        follows the Poisson distribution.
        
        
        Calls
        -----
        chi_squared_test
        
        
        """
        if not hasattr(self, 'pvals'):
            self.Binomial_p_test()
        #end if
        self.chi_t_vals, self.chi_p_vals, self.chi_k_vals = \
            chi_squared_test(self.rvals, self.n_points, self.distribution)
        #end func
    #end func
    
    def Binomial_p_test(self):
        """
        Performs a p test to determine if a result is statistically 
        significant, if the data is assumed to follow the Binomial 
        distribution.
        
        
        Calls
        -----
        Binomial_test
        
        
        """
        if not hasattr(self, 'xvals'):
            self.compute_parameters_for_binomial_test()
        #end if
        self.pvals = Binomial_test(self.xvals, self.mvals, self.n_points)
    #end func
    
    def Plots(self, wd_images):
        """
        Generates plots.
        
        
        Parameters
        ----------
        wd_images: string
            Directory in which to save figures.
        
        
        Calls
        -----
        plotting.plot_distribution_at_depth_slice
        
        plotting.plot_Binomial_p_values
        
        
        """
        pt.plot_distribution_at_depth_slice(self, self.depths, wd_images)
        if len(self.depths) > 1:
            pt.plot_Binomial_p_values(self, wd_images)
        #end if
    #end func
    
    def print_results(self):
        """
        Function to print results of the statistical test to the console, or to
        stdout. This function is called to print information to an output file.
        
        
        """
        print('Test =', self.name)
        print('Test distribution type =', self.distribution)
        print('Number of deposits =', self.n_points)
        print('Number of repeats =', self.n_repeats)
        print('Depths =', self.depths)
        print('Criteria:')
        criteria = self.node.findall("criterion")
        for criterion in criteria:
            name = criterion.attrib["name"]
            _, target_range, target_value = \
                fn.changetype(criterion.attrib["description"], list, dtype=str)
            feature = criterion.attrib["feature"]
            print('%s:'%name, 'distance', target_range, target_value, 'from',
                  feature)
        #end for
        print(self.distribution, 'distribution probability test results:')
        print('Proportion of deposits satisfying criteria, x =', self.xvals)
        print('Proportion of random points satisfying criteria, m =', 
              self.mvals)
        print('Probability of obtaining x with mean m, p =', self.pvals)
        print('Chi squared test results:')
        print('t values =', self.chi_t_vals)
        print('p values =', self.chi_p_vals)
        print('k values =', self.chi_k_vals)
    #end func
#end class
    
def chi_squared_test(rvals, n_points, distribution):
    """
    Performs the chi squared test to determine whether or not a data set
    follows a given distribution.
    
    
    Parameters
    ----------
    rvals: numpy array
        2D array with dimensions (n_depths, n_repeats) representing the 
        proportions of points which fulfil the criteria of the statistical 
        test.
        
    n_points: integer
        The number of deposit locations used.
        
    distribution: string
        Flag representing which distribution to test the data against. 
        Supported values are 'Poisson' and 'Binomial'.
        
        
    Returns
    -------
    tvals: numpy array
        1D numpy array representing the test statistic values calculated for
        each depth.
        
    pvals: numpy array
        1D numpy array representing the p values at each depth.
        
    kvals: numpy array
        1D numpy array representing degrees of freedom at each depth.
        
        
    Calls
    -----
    functions.Poisson
    
    functions.binomial
    
    
   """
    tvals = list()
    pvals = list()
    kvals = list()
    for i in range(len(rvals)):
        r = rvals[i]*n_points
        freqs, binedges = np.histogram(r, bins=n_points+1, 
                                       range=(0, n_points+1))
        x = binedges[:-1]
        m = np.mean(r)
        if distribution == 'Poisson':
            y = fn.Poisson(x, m)*len(r)
        elif distribution == 'Binomial':
            y = fn.binomial(x, m, n_points)*len(r)
        #end if
        #Maybe make smallest allowable expectation value an input?
        #maxind = np.max(np.where(y >= np.max([5, 0.01*len(r)]))[0])
        bins = np.where(y >= 5)[0]
        minind = np.min(bins)
        maxind = np.max(bins)
        #DoF = Number of bins minus 1, minus 1 because of assumed mean
        if len(bins) > 2:
            k = len(bins) - 2
            freqs = freqs[minind:maxind]
            y = y[minind:maxind]
            O = np.hstack([freqs, np.array([len(r) - np.sum(freqs)])])
            E = np.hstack([y, np.array([len(r) - np.sum(y)])])
            chi2 = np.sum((O-E)**2/E)
            p = 1 - gammainc(k/2, chi2/2)
            tvals.append(chi2)
            pvals.append(p)
            kvals.append(k)
        else:
            tvals.append(np.nan)
            pvals.append(np.nan)
            kvals.append(np.nan)
        #end if
    #end for
    return np.array(tvals), np.array(pvals), np.array(kvals)
#end func
    
def compute_truth_arrays(distance_arrays, conditions, 
                         grouping_type='intersection'):
    """
    Determines whether or not a set of points fulfils the given conditions.
    
    
    Parameters
    ----------
    distance_arrays: list
        List of structured numpy arrays containing distances from deposit 
        locations and random locations from features under investigation.
        
    conditions: list
        A list of lists. Each sub list is to contain two elements:
            1. "range" to use, e.g. 'less than', 'greater than'
            2. Threshold value to compare to.
            
    grouping_type: string
        Either 'intersection' or 'union'. If 'intersection', all criteria must
        be fulfilled. If 'union', any criterion must be fulfilled.
        
        
    Returns
    -------
    truth1: numpy array
        Array of truth values representing whether or not deposit locations 
        fulfil the criteria.
        
    truth2: numpy array
        Array of truth values representing whether or not random locations 
        fulfil the criteria.
    
    
    """
    list1 = list()
    list2 = list()
    for i in range(len(distance_arrays)):
        condition = conditions[i]
        thr = condition[1]
        rng = condition[0]
        distance_array = distance_arrays[i]
        distances = distance_array['distance']
        distances_random = distance_array['distance_random']
        if rng == 'less than':
            list1.append(distances < thr)
            list2.append(distances_random < thr)
        elif rng == 'greater than':
            list1.append(distances > thr)
            list2.append(distances_random > thr)
        #end if
    #end for
    if grouping_type == 'union':
        truth1 = np.any(list1, axis=0)
        truth2 = np.any(list2, axis=0)
    elif grouping_type == 'intersection':
        truth1 = np.all(list1, axis=0)
        truth2 = np.all(list2, axis=0)
    #end if
    return truth1, truth2
#end func

def compute_parameters_for_p_test(real, random, n_points):
    """
    Computes parameters for the Poisson p test.
    
    
    Parameters
    ----------
    real: numpy array
        2D rray of truth values representing whether or not a deposit location
        satisfies all criteria, for each depth.
        
    random: numpy array
        3D Array of truth values representing whether or not a random location
        satisfies all criteria, for each repeat, for each depth.
        
    n_points: integer
        The number of deposit locationsused.
        
        
    Returns
    -------
    xvals: numpy array
        1D array, containing the proportion of points at each depth which 
        satisfied all criteria.
        
    rvals: numpy array
        2D array, containing the proportion of points for each repeat and for
        each depth which satisfied all criteria.
        
    mvals: numpy array
        1D array containing the mean value of rvals at each depth.
        
    svals: numpy array
        1D array containing the standard deviation of rvals at each depth.
    
    
    """
    xvals = np.sum(real, axis=1)/n_points
    rvals = np.sum(random, axis=2)/n_points
    mvals = np.mean(rvals, axis=1)
    svals = np.std(rvals, axis=1)
    return xvals, mvals, svals, rvals
#end func
    
def compute_cdf(distance_array, cdf_array):
    """
    Computes the cumulative distribution function for the distances from 
    deposit locations and random locations to a feature.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing the distances from deposits and random 
        locations to the feature.
        
    cdf_array: numpy array
        Structured array to enter the CDF into.
        
        
    Returns
    -------
    cdf_array: numpy array
        Structured array to with CDF entered into it.
        
    
    """
    distances = distance_array['distance']
    distance_random = distance_array['distance_random']
    
    for i in range(distances.shape[0]):
        
        hist_kwargs = dict(cumulative=True, bins=cdf_array['bins'][i], 
                           histtype='step', density=False)
        rhist_kwargs = dict(cumulative=True, bins=cdf_array['bins'][i], 
                            histtype='step', density=False)
  
        if not np.all(distances[i] == 0):
            cdf_array['cdf'][i], _, _= \
                plt.hist(distances[i], **hist_kwargs)
        #end if

        for j in range(distance_random.shape[1]):
            cdf_array['cdf_random'][i, j], _, _ = \
                plt.hist(distance_random[i, j], **rhist_kwargs)
        #end if
    #end for
    plt.close()
    return cdf_array
#end func

def compute_normed_cdf(cdf_array, n_deposits, correlation):
    """
    Computes a normed cumulative distribution function from an already existing
    CDF, and computes the maximum distance (d value) between the CDFs for real 
    deposit locations and random locations.
    
    
    Parameters
    ----------
    cdf_array: numpy array
        Structured array containing the CDF.
        
    n_deposits: integer
        Number of deposits used.
        
    correlation: string
        Either 'Positive', 'Negative', or 'Neutral' to describe whether we want
        the d value for a positive or negative correlation, or any.
        
    
    Returns
    -------
    cdf_normed: numpy array
        2D array containing the normed CDF for real deposits at each depth.
    
    cdf_random_normed: numpy array
        2D array containing the mean of the normed CDF for random locations for 
        each repeat at each depth.
    
    cdf_random_std: numpy array
        2D array containing the standard deviation for cdf_random_normed at 
        each depth.
    
    dvalues: numpy array
        The difference between cdf_normed and cdf_random_normed at each depth.
    
    dmax: numpy array
        The maximum value of dvalues at each depth.
    
    
    """

    cdf_normed = cdf_array['cdf']/n_deposits
    cdf_random_normed = np.mean(cdf_array['cdf_random'], axis=1)/n_deposits
    cdf_random_std = np.std(cdf_array['cdf_random'], axis=1)/n_deposits        

    if correlation == 'Positive':
        dvalues = cdf_normed - cdf_random_normed
    elif correlation == 'Negative':
        dvalues = cdf_random_normed - cdf_normed
    elif correlation == 'Neutral':
        dvalues = np.abs(cdf_normed - cdf_random_normed)
    #end if

    dmax = np.nanmax(dvalues, axis=1)
    return cdf_normed, cdf_random_normed, cdf_random_std, dvalues, dmax
#end func 
    
def compute_normed_pdf(cdf_array, n_deposits):
    """
    Computes a normed probability density function from an already existing 
    PDF, for real deposit locations and random locations.
    
    
    Parameters
    ----------
    cdf_array: numpy array
        Structured array containing the PDF.
        
    n_deposits: integer
        Number of deposits used.
        
    
    Returns
    -------
    pdf_normed: numpy array
        2D array containing the normed PDF for real deposits at each depth.
    
    pdf_random_normed: numpy array
        2D array containing the mean of the normed PDF for random locations for 
        each repeat at each depth.
    
    pdf_random_std: numpy array
        2D array containing the standard deviation for pdf_random_normed at 
        each depth.
    
    
    """

    pdf_normed = cdf_array['pdf']/n_deposits
    pdf_random_normed = np.mean(cdf_array['pdf_random'], axis=1)/n_deposits
    pdf_random_std = np.std(cdf_array['pdf_random'], axis=1)/n_deposits        

    return pdf_normed, pdf_random_normed, pdf_random_std
#end func 
    
def compute_pdf(distance_array, cdf_array):
    """
    Computes the probability density function for the distances from deposit 
    locations and random locations to a feature.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing the distances from deposits and random 
        locations to the feature.
        
    cdf_array: numpy array
        Structured array to enter the PDF into.
        
        
    Returns
    -------
    cdf_array: numpy array
        Structured array to with CDF entered into it.
        
    
    """
    distances = distance_array['distance']
    distance_random = distance_array['distance_random']
    
    for i in range(distances.shape[0]):
        
        hist_kwargs = dict(cumulative=False, bins=cdf_array['bins'][i], 
                           histtype='step', density=False)
        rhist_kwargs = dict(cumulative=False, bins=cdf_array['bins'][i], 
                            histtype='step', density=False)
  
        if not np.all(distances[i] == 0):
            cdf_array['pdf'][i], _, _= \
                plt.hist(distances[i], **hist_kwargs)
        #end if

        for j in range(distance_random.shape[1]):
            cdf_array['pdf_random'][i, j], _, _ = \
                plt.hist(distance_random[i, j], **rhist_kwargs)
        #end if
    #end for
    plt.close()
    return cdf_array
#end func

def initialise_bins(binsize, distance_array):
    """
    Takes a distance array and computes the bins needed for a histogram, to 
    compute the PDF and CDF for the distances.
    
    
    Parameters
    ----------
    binsize: float
        Width of bin in histogram.
        
    distance_array: numpy array
        Structured array containing distance to feature information.
        
        
    Returns
    -------
    bins: numpy array
        The values at the edges of each bin. Will have length nbins + 1.
        
    binc: numpy array
        The value at the centre of each bin. Will have length nbins.
        
    
    """
    if binsize is None:
        binsize = 2e3
    #end if
    min_random = distance_array['distance_random'].min()
    min_real =distance_array['distance'].min()
    max_random = distance_array['distance_random'].max()
    max_real = distance_array['distance'].max()
    min_val = min(min_random, min_real)
    max_val = max(max_random, max_real)
    bins = np.arange((np.floor(min_val/binsize)-1.0), 
                     (np.ceil(max_val/binsize)+1.0),
                     1.0)*binsize
    binc = np.mean([bins[:-1], bins[1:]],axis=0) 
    return bins, binc    
#end func
    
def initialise_cdf_array(distance_array, binsize):
    """
    Creates a structured array to store computed CDFs and PDFs.
    
    
    Parameters
    ----------
    distance_array: numpy array
        Structured array containing distance to feature information.
        
    binsize: float
        Width of bin in histogram.
        
        
    Returns
    -------
    array: numpy array
        Structured array designed to contain CDF and PDF information.
        
    n_deposits: integer
        Number of deposits used for analysis.
        
    
    Calls
    -----
    initialise_bins
    
    
    """
    
    bins, binc = initialise_bins(binsize, distance_array)
    # initialise an array to contain cdf
    n_bins = binc.shape[0]
    n_repeats = distance_array['distance_random'].shape[1]
    array = np.zeros(len(distance_array['distance']),
                     dtype=[('depth', np.float), 
                            ('binc', np.float, binc.shape),
                            ('bins', np.float, bins.shape),
                            ('cdf_random', np.float, (n_repeats, n_bins)),
                            ('cdf', np.float, binc.shape),
                            ('pdf_random', np.float, (n_repeats, n_bins)),
                            ('pdf', np.float, binc.shape)])
    array['depth'] = distance_array['depth']
    for i in range(distance_array['distance'].shape[0]):
        array['bins'][i] = bins
        array['binc'][i] = binc
    #end for
    n_deposits = distance_array['distance'].shape[1]
    return array, n_deposits
#end func
    
def Poisson_test(x, m, n_points):
    """
    Performs a test to determine the probability of a given result occurring
    if the Poisson distribution is followed.
    
    
    Parameters
    ----------
    x: numpy array
        1D array containing the observed number of points which fulfilled a set
        of criteria at each depth.
        
    m: numpy array
        1D array containing the observed number of random locations which 
        fulfilled the same set of criteria as x at each depth.
        
    n_points: integer
        The number of points used.
        
    
    Returns
    -------
    pvals: numpy array
        1D array containing the probability that 'x' could occur with mean 'm' 
        for each depth.
        
        
    Calls
    -----
    functions.Poisson
    
    
    """
    pvals = list()
    for i in range(len(x)):
        p = fn.Poisson(x[i]*n_points, m[i]*n_points)
        pvals.append(p)
    #end func
    return np.array(pvals)
#end func
    
def Binomial_test(x, m, n_points):
    """
    Performs a test to determine the probability of a given result occurring
    if the Binomial distribution is followed.
    
    
    Parameters
    ----------
    x: numpy array
        1D array containing the observed number of points which fulfilled a set
        of criteria at each depth.
        
    m: numpy array
        1D array containing the observed number of random locations which 
        fulfilled the same set of criteria as x at each depth.
        
    n_points: integer
        The number of points used.
        
    
    Returns
    -------
    pvals: numpy array
        1D array containing the probability that 'x' could occur with mean 'm' 
        for each depth.
        
        
    Calls
    -----
    functions.binomial
    
    
    """
    pvals = list()
    for i in range(len(x)):
        p = fn.binomial(x[i]*n_points, m[i]*n_points, n_points)
        pvals.append(p)
    #end func
    return np.array(pvals)
#end func
    
def make_distance_array(feature, point_data, n_repeats, points_random=None, 
                        RPManager=None):
    """
    Make and populate an array to contain distances to contour.
    
    
    Parameters
    ----------
    point_data_xy : array
        Array of projected coordinates of deposit locations for which distances 
        are to be computed.
    
    gcz : array
        Array of depth values for which geophysical model was created.
    
    n_repeats : int
        Number of repeats of the analysis to perform for random points.
        
    
    Returns
    -------
    distance_array : array
        Structured array to contain distance-to-contour data.
    
        
    """
    
    # initialise structured array to contain distance-to-contour data  
    gcz = feature.gcz
    n_points = len(point_data)
    distance_array = np.array(np.zeros(len(gcz)),
                              dtype=[('depth', np.float),
                                     ('lon',np.float, n_points),
                                     ('lat',np.float, n_points),
                                     ('distance_random', np.float, \
                                      (n_repeats, n_points)),
                                     ('distance', np.float, n_points)])
    distance_array['depth'] = gcz
    distance_array['lon'] = point_data[:,0]
    distance_array['lat'] = point_data[:,1]
    if points_random is None:
        points_random = RPManager.seed_random_points(n_repeats=n_repeats)
    #end if
    if len(gcz) == 1:
        distance_array['distance'][0] = \
            feature.fun((point_data[:,0], point_data[:,1]))
        distance_array['distance_random'][0] = \
            feature.fun((points_random[:,:,0], points_random[:,:,1]))
    else:
        for i in range(len(gcz)):
            distance_array['distance'][i] = \
                feature.fun((point_data[:,0], point_data[:,1], 
                             gcz[i]*np.ones_like(point_data[:,0])))
            distance_array['distance_random'][i] = \
                feature.fun((points_random[:,:,0], points_random[:,:,1], 
                             gcz[i]*np.ones_like(points_random[:,:,0])))
        #end for
    #end if
    return distance_array
#end func